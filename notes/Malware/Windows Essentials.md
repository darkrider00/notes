![[Pasted image 20240511123230.png]]

- user process is something executed by the user sunch as notepad , google or word.
DLL
 - refer to this  https://learn.microsoft.com/en-us/troubleshoot/windows-client/setup-upgrade-and-drivers/dynamic-link-library
 - provides functionality of OS
 - contains code and data can be used  by more than one program 
Subsystem Dll contain API functionality called by user processes example is kernel32.dll
- https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea (Within kernel32.dll, there exists a function called `CreateFile`. This function is part of the Windows API (WinAPI), which is a set of functions and procedures that allows developers to interact with the Windows operating system.)

- api functions allow diff software apps to communicate with each other refer https://www.indeed.com/career-advice/career-development/api-functions

**Ntdll.dll** (system wide dll)
- system wide dll means it is accessible and utilized by multiple programs across entire system (contains essential functions)
- it is lowers layer available in user mode (serves as gateway b/w 2 modes)
- this dll provides transition of execution from user mode to kernel mode
	- here transitions means that (sometimes when user executes program they require high privileges to access that process so it must transition from user mode to kernel mode(accomplished by system calls))
- also referred to as native API

Executive kernel is known as window kernel it calls drivers and modules wihtin kernel mode to complete tasks

###  **Function Call Flow**
![[Pasted image 20240511130021.png]]


a function call begins with user application calling create file WINAPI function in kernel32.dll
createfile calls it's equivalent NTAPI function NtCreateFile providd through Ntdll then execute assembly  or sys call instruction which transfers execution to kernel mode , once execution enters kernel mode kernel's implementation of the NtCreateFile function is invoked (handles I/O op, access control checks etc)

### **Example**
![[Pasted image 20240511130846.png]]
Windows API simply acts as a wrapper for the Native API. With that being said, the Native API is more difficult to use because it is not officially documented by Microsoft. Furthermore, Microsoft advises against the use of Native API functions because they can be changed at any time without warning.



### Memory management
![[Pasted image 20240511131015.png]]

Instead of directly accessing physical memory addresses, processes interact with virtual memory addresses, which are then mapped to physical memory addresses by the operating system.
This mapping allows for several benefits, including efficient memory utilization and the ability to run multiple processes simultaneously while maintaining isolation between them.

- pages within virtual memory can be in 3 states
	 - free (neither committed nor reserved not accessible to the process available to be reserved or committed )
	 - reserved - reserved for future use
	 - committed - can be accessible and access is controlled by memory protection contestants

### Page -protection
```
PAGE_NOACCESS
PAGE_EXECUTE_READWRITE
PAGE_READONLY
```
### **Memory Protection**
Data Execution Prevention (DEP) -  prevent executing code in that region
Address space layout randomization (ASLR) - prevent exploitation of memory corruption vuln

### **x86 vs x64 Memory Space**

When working with Windows processes, it's important to note whether the process is x86 or x64. x86 processes have a smaller memory space of 4GB (`0xFFFFFFFF`) whereas x64 has a vastly larger memory space of 128TB (`0xFFFFFFFFFFFFFFFF`).


we can interact with windows memory via C
```
/ Allocating a memory buffer of *100* bytes

// Method 1 - Using malloc()
PVOID pAddress = malloc(100);

// Method 2 - Using HeapAlloc()
PVOID pAddress = HeapAlloc(GetProcessHeap(), 0, 100);

// Method 3 - Using LocalAlloc()
PVOID pAddress = LocalAlloc(LPTR, 100);
```

Memory allocation functions return the _base address_ which is simply a pointer to the beginning of the memory block that was allocated.

`pAddress` looks like
![[Pasted image 20240511132028.png]]

When memory is allocated, it may either be empty or contain random data. Some memory allocation functions provide an option to zero out the memory region during the allocation process.
![[Pasted image 20240511132045.png]]
next step after memory allocation is generally writing to that buffer. Several options can be used to write to memory but for this example, `memcpy` is used.

```
PVOID pAddress	= HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 100);

CHAR* cString	= "MalDev Academy Is The Best";

memcpy(pAddress, cString, strlen(cString));
```

`HeapAlloc` uses the `HEAP_ZERO_MEMORY` flag which causes the allocated memory to be initialized to zero. The string is then copied to the allocated memory using `memcpy`. The last parameter in `memcpy` is the number of bytes to be copied. Next, recheck the buffer to verify that the data was successfully written
![[Pasted image 20240511132154.png]]


### Freeing allocated memory
- Allocating with `malloc` requires the use of the `free` function.

- Allocating with `HeapAlloc` requires the use of the `HeapFree` function.

- Allocating with `LocalAlloc` requires the use of the `LocalFree` function.
When the application is done using an allocated buffer, it is highly recommended to deallocate or free the buffer to avoid memory leaks refer https://en.wikipedia.org/wiki/Memory_leak

The images below show `HeapFree` in action, freeing allocated memory at address `0000023ADE449900`. Notice the address `0000023ADE449900` still exists within the process but its original content was overwritten with random data. This new data is most likely due to a new allocation performed by the OS inside the process.
![[Pasted image 20240511132554.png]]
![[Pasted image 20240511132548.png]]

## Windows API
way for application to interact with OS
example : if app needs to display something on screen or modify all these actions can be done via Windows API

**data types :**
refer [https://learn.microsoft.com/en-us/windows/win32/winprog/windows-data-types]

DWORD -32 it unsigned integer both 32 bit and 64 bit 
```
DWORD dwVariable = 42;
```
size_t - 32 bit unsigned int (2^32-1)
```
SIZE_T sVariable = sizeof(int);
```
VOID -abscence
```
void* pVariable = NULL; // This is the same as PVOID
```
Pvoid -32 bit pointer of any data type
```
PVOID pVariable = &SomeData;
```
HANDLE -value that specifies specific object
```
HANDLE hFile = CreateFile(...);
```
HMODULE - handle module 
```
HMODULE hModule = GetModuleHandle(...);
```
etc refere to the link for more 

#### Data Type Pointers

- `PHANDLE` is the same as `HANDLE*`.

- `PSIZE_T` is the same as `SIZE_T*`.

- `PDWORD` is the same as `DWORD*`.

#### **ANSI & Unicode Functions**
The majority of Windows API functions have two versions ending with either "A" or with "W". For example, there is [CreateFileA](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea) and [CreateFileW](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew). The functions ending with "A" are meant to indicate "ANSI" whereas the functions ending with "W" represent Unicode or "Wide".
- Ansi function (8 bits) will take ANSI data type as parameters
	 - each char occupies one byte and null terminator (total mem = num of char + null terminator)
- Unicode function (16 bits) will take in Unicode as data types
     - each char occupies 2 bytes (total mem is num of char multiplied by 2 +2 for null terminator)
```
first parameter for `CreateFileA` is an `LPCSTR`, which is a pointer to a constant null-terminated string of **8-bit** Windows ANSI characters. On the other hand, the first parameter for `CreateFileW` is `LPCWSTR`, a pointer to a constant null-terminated string of **16-bit** Unicode characters.

Furthermore, the number of required bytes will differ depending on which version is used.

`char str1[] = "maldev";` // 7 bytes (maldev + [null byte]
`wchar str2[] = L"maldev";` // 14 bytes, each character is 2 bytes (The null byte is also 2 bytes)
```
refer https://www.tutorialandexample.com/null-character-in-c

### **Find the API Reference**

It's important to always reference the documentation if one is unsure about what the function does or what arguments it requires.
example 
The `CreateFileW` documentation is available [here](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew).

```
HANDLE CreateFileW(
  [in]           LPCWSTR               lpFileName,
  [in]           DWORD                 dwDesiredAccess,
  [in]           DWORD                 dwShareMode,
  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  [in]           DWORD                 dwCreationDisposition,
  [in]           DWORD                 dwFlagsAndAttributes,
  [in, optional] HANDLE                hTemplateFile
);
```

- When you use `CreateFileW` successfully, it gives you something called a "handle." This handle is like a ticket that allows you to interact with the file or device you created or opened.
- When you use CreateFileW, you provide it with some information about what you want to create or open. These are things like the name of the file or device, how you want to use it, and any special options.

#### using the function
The sample code below goes through an example usage of `CreateFileW`. It will create a text file with the name `maldev.txt` on the current user's Desktop.

```
// This is needed to store the handle to the file object
// the 'INVALID_HANDLE_VALUE' is just to intialize the variable
Handle hFile = INVALID_HANDLE_VALUE;

// The full path of the file to create.
// Double backslashes are required to escape the single backslash character in C
LPCWSTR filePath = L"C:\\Users\\maldevacademy\\Desktop\\maldev.txt";

// Call CreateFileW with the file path
// The additional parameters are directly from the documentation
hFile = CreateFileW(filePath, GENERIC_ALL, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

// On failure CreateFileW returns INVALID_HANDLE_VALUE
// GetLastError() is another Windows API that retrieves the error code of the previously executed WinAPI function
if (hFile == INVALID_HANDLE_VALUE){
    printf("[-] CreateFileW Api Function Failed With Error : %d\n", GetLastError());
    return -1;
}
```

if the CreateFileW fails it returns INVALID_HANDLE_VALUE which indicates file is not created , to gain more insights error code must be retrieved using GetLastError method
to know more about this error handling technique refer :https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror
 once we get the information about the error we can look up in error codes list
 refer https://learn.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-
 
- `5` - ERROR_ACCESS_DENIED

- `2` - ERROR_FILE_NOT_FOUND

- `87` - ERROR_INVALID_PARAMETER

are common error codes

### **Windows Native API Debugging Errors**
NTAPI are mostly exported from ntdll.dll unlike windows API these functions cannot have their error codes fetched via GetLastError instead represente by INSTATUS data type

- NSTATUS is used to represent the status of a system call or function or fucntion (32-bit unsigned integer value)
refer : https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55
```
NTSTATUS STATUS = NativeSyscallExample(...);
if (STATUS != STATUS_SUCCESS){
    // printing the error in unsigned integer hexadecimal format
    printf("[!] NativeSyscallExample Failed With Status : 0x%0.8X \n", STATUS);
}

// NativeSyscallExample succeeded
```

### **NT_SUCCESS Macro**

Another way to check the return value of NTAPIs is through the `NT_SUCCESS` macro shown. The macro returns `TRUE` if the function succeeded, and `FALSE` it fails.

```
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
```

Below, is an example of using this macro

```
NTSTATUS STATUS = NativeSyscallExample(...);
if (!NT_SUCCESS(STATUS)){
    // printing the error in unsigned integer hexadecimal format
    printf("[!] NativeSyscallExample Failed With Status : 0x%0.8X \n", STATUS);
}

// NativeSyscallExample succeeded
```
refer : https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values

## PE (portable executable format)
- file format for ex3ecutables on win 
- eg : .exe , .dll, .sys, .scr
![[Pasted image 20240512110112.png]]

Every header shown in the image is defined as a data structure that holds information about the PE file.

DOS header
- first header file of PE is always prefixed with 2 bytes  0x4D 0x5A
- used to confirm that the file being parsed or inspected is valid PE or not
```
typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // Offset to the NT header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
```
DOS stub which is an error message that prints "This program cannot be run in DOS mode" in case the program is loaded in DOS mode or "Disk Operating Mode". It is worth noting that the error message can be changed by the programmer at compile time. This is not a PE header, but it's good to be aware of it.
refer : https://en.wikipedia.org/wiki/DOS

NT header contains infor about PE file
- contains signature element which equal to PE

The NT header structure varies depending on the machine's architecture.

**32-bit Version:**

```
typedef struct _IMAGE_NT_HEADERS {
  DWORD                   Signature;
  IMAGE_FILE_HEADER       FileHeader;
  IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
```

**64-bit Version:**

```
typedef struct _IMAGE_NT_HEADERS64 {
    DWORD                   Signature;
    IMAGE_FILE_HEADER       FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;
```

The only difference is the `OptionalHeader` data structure, `IMAGE_OPTIONAL_HEADER32` and `IMAGE_OPTIONAL_HEADER64`.
### **File Header (IMAGE_FILE_HEADER)**

Moving on to the next header, which can be accessed from the previous NT Header data structure

```
typedef struct _IMAGE_FILE_HEADER {
  WORD  Machine;
  WORD  NumberOfSections;
  DWORD TimeDateStamp;
  DWORD PointerToSymbolTable;
  DWORD NumberOfSymbols;
  WORD  SizeOfOptionalHeader;
  WORD  Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
```

The most important struct members are:

- `NumberOfSections` - The number of sections in the PE file (discussed later).

- `Characteristics` - Flags that specify certain attributes about the executable file, such as whether it is a dynamic-link library (DLL) or a console application.

- `SizeOfOptionalHeader` - The size of the following optional header
refer : https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_file_header
**32-bit Version:**

```
typedef struct _IMAGE_OPTIONAL_HEADER {
  WORD                 Magic;
  BYTE                 MajorLinkerVersion;
  BYTE                 MinorLinkerVersion;
  DWORD                SizeOfCode;
  DWORD                SizeOfInitializedData;
  DWORD                SizeOfUninitializedData;
  DWORD                AddressOfEntryPoint;
  DWORD                BaseOfCode;
  DWORD                BaseOfData;
  DWORD                ImageBase;
  DWORD                SectionAlignment;
  DWORD                FileAlignment;
  WORD                 MajorOperatingSystemVersion;
  WORD                 MinorOperatingSystemVersion;
  WORD                 MajorImageVersion;
  WORD                 MinorImageVersion;
  WORD                 MajorSubsystemVersion;
  WORD                 MinorSubsystemVersion;
  DWORD                Win32VersionValue;
  DWORD                SizeOfImage;
  DWORD                SizeOfHeaders;
  DWORD                CheckSum;
  WORD                 Subsystem;
  WORD                 DllCharacteristics;
  DWORD                SizeOfStackReserve;
  DWORD                SizeOfStackCommit;
  DWORD                SizeOfHeapReserve;
  DWORD                SizeOfHeapCommit;
  DWORD                LoaderFlags;
  DWORD                NumberOfRvaAndSizes;
  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;
```

**64-bit Version:**

```
typedef struct _IMAGE_OPTIONAL_HEADER64 {
  WORD                 Magic;
  BYTE                 MajorLinkerVersion;
  BYTE                 MinorLinkerVersion;
  DWORD                SizeOfCode;
  DWORD                SizeOfInitializedData;
  DWORD                SizeOfUninitializedData;
  DWORD                AddressOfEntryPoint;
  DWORD                BaseOfCode;
  ULONGLONG            ImageBase;
  DWORD                SectionAlignment;
  DWORD                FileAlignment;
  WORD                 MajorOperatingSystemVersion;
  WORD                 MinorOperatingSystemVersion;
  WORD                 MajorImageVersion;
  WORD                 MinorImageVersion;
  WORD                 MajorSubsystemVersion;
  WORD                 MinorSubsystemVersion;
  DWORD                Win32VersionValue;
  DWORD                SizeOfImage;
  DWORD                SizeOfHeaders;
  DWORD                CheckSum;
  WORD                 Subsystem;
  WORD                 DllCharacteristics;
  ULONGLONG            SizeOfStackReserve;
  ULONGLONG            SizeOfStackCommit;
  ULONGLONG            SizeOfHeapReserve;
  ULONGLONG            SizeOfHeapCommit;
  DWORD                LoaderFlags;
  DWORD                NumberOfRvaAndSizes;
  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;
```
he optional header contains a ton of information that can be used. Below are some of the struct members that are commonly used:

- `Magic` - Describes the state of the image file (32 or 64-bit image)

- `MajorOperatingSystemVersion` - The major version number of the required operating system (e.g. 11, 10)

- `MinorOperatingSystemVersion` - The minor version number of the required operating system (e.g. 1511, 1507, 1607)

- `SizeOfCode` - The size of the `.text` section (Discussed later)

- `AddressOfEntryPoint` - Offset to the entry point of the file (Typically the _main_ function)

- `BaseOfCode` - Offset to the start of the `.text` section

- `SizeOfImage` - The size of the image file in bytes

- `ImageBase` - It specifies the preferred address at which the application is to be loaded into memory when it is executed. However, due to Window's memory protection mechanisms like Address Space Layout Randomization (ASLR), it's rare to see an image mapped to its preferred address because the Windows PE Loader maps the file to a different address. This random allocation done by the Windows PE loader will cause issues in the implementation of future techniques because some addresses that are considered constant were changed. The Windows PE loader will then go through _PE relocation_ to fix these addresses.

- `DataDirectory` - One of the most important members in the optional header. This is an array of [IMAGE_DATA_DIRECTORY](https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_data_directory), which contains the directories in a PE file (discussed below).

### DATA Directory
- can be accessed from optional header
- an array of data type IMAGE_DATA_DIRECTORY
```
typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
```
size `IMAGE_NUMBEROF_DIRECTORY_ENTRIES` which is a constant value of `16`

A specific data directory can be accessed using its index in the array.

```
#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor
```

The two sections below will briefly mention two important data directories, the `Export Directory` and `Import Address Table`.

export directoty - infor about functions or variables
Address table - info about address functions 

### PE SECTIONS
contain the code and data used to create an executable program. Each PE section is given a unique name and typically contains executable code, data, or resource information. There is no constant number of PE sections because different compilers can add, remove or merge sections depending on the configuration. Some sections can also be added later on manually, therefore it is dynamic and the `IMAGE_FILE_HEADER.NumberOfSections` helps determine that number.

IMP sections
- `.text` - Contains the executable code which is the written code.

- `.data` - Contains initialized data which are variables initialized in the code.

- `.rdata` - Contains read-only data. These are constant variables prefixed with `const`.

- `.idata` - Contains the import tables. These are tables of information related to the functions called using the code. This is used by the Windows PE Loader to determine which DLL files to load to the process, along with what functions are being used from each DLL.

- `.reloc` - Contains information on how to fix up memory addresses so that the program can be loaded into memory without any errors.

- `.rsrc` - Used to store resources such as icons and bitmaps

Each PE has an image section header that contains valubele info about it 
- saved under NT headers in PE file stacked above each other where each represents a section
refer : https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header
```
typedef struct _IMAGE_SECTION_HEADER {
  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];
  union {
    DWORD PhysicalAddress;
    DWORD VirtualSize;
  } Misc;
  DWORD VirtualAddress;
  DWORD SizeOfRawData;
  DWORD PointerToRawData;
  DWORD PointerToRelocations;
  DWORD PointerToLinenumbers;
  WORD  NumberOfRelocations;
  WORD  NumberOfLinenumbers;
  DWORD Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
```

### **Additional References**

In case further clarification is required on certain sections, the following blog posts on [0xRick's Blog](https://0xrick.github.io/) are highly recommended.

- PE Overview - [https://0xrick.github.io/win-internals/pe2/](https://0xrick.github.io/win-internals/pe2/)

- DOS Header, DOS Stub and Rich Header - [https://0xrick.github.io/win-internals/pe3/](https://0xrick.github.io/win-internals/pe3/)

- NT Headers - [https://0xrick.github.io/win-internals/pe4/](https://0xrick.github.io/win-internals/pe4/)

- Data Directories, Section Headers and Sections - [https://0xrick.github.io/win-internals/pe5/](https://0xrick.github.io/win-internals/pe5/)

- PE Imports (Import Directory Table, ILT, IAT) - [https://0xrick.github.io/win-internals/pe6/](https://0xrick.github.io/win-internals/pe6/)

# DLL
![[Pasted image 20240512114727.png]]

The above is the DLL loaded and used by explorer application
### System wide DLL

- used to load some DLLs at the same base address in virtual address space of all process on a given machine to optimize memory usage
![[Pasted image 20240512131125.png]]

Use of DLL
Modularization of code
code reuse 
efficient mem usage

Sample DLL

```
BOOL APIENTRY DllMain(
    HANDLE hModule,             // Handle to DLL module
    DWORD ul_reason_for_call,   // Reason for calling function
    LPVOID lpReserved           // Reserved
) {

    switch (ul_reason_for_call) {
        case DLL_PROCESS_ATTACHED: // A process is loading the DLL.
        // Do something here
        break;
        case DLL_THREAD_ATTACHED: // A process is creating a new thread.
        // Do something here
        break;
        case DLL_THREAD_DETACH: // A thread exits normally.
        // Do something here
        break;
        case DLL_PROCESS_DETACH: // A process unloads the DLL.
        // Do something here
        break;
    }
    return TRUE;
}
```

can be used by calling app;ications and process
```
////// sampleDLL.dll //////

extern __declspec(dllexport) void HelloWorld(){
// Function code here
}
```

Dynamic linking - it's possible to use LoadLibrary, GetModuleHandle and GetProcAddress WINAPIs to imort a fucntion in DLL 
refer to : https://learn.microsoft.com/en-us/windows/win32/dlls/load-time-dynamic-linking

Loading DLL 
refer to : https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxa
calling function such as above will force OS to load DLL into calling process's memory address space 
to call the function first it needs to retrieve DLL's handle that is exporting the function if the application doesn't have sample.dll loaded into the memory then it would require the usage of the LoadLibrary WinAPI, as shown below.
```
HMODULE hModule = LoadLibraryA("sampleDLL.dll"); // hModule now contain sampleDLL.dll's handle
```
https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya

Retrieving DLL's handle - get module handle WInAPI fucntion without LoadLibrary
```
HMODULE hModule = GetModuleHandleA("sampleDLL.dll");
```
refer to : https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea

Retrieveing a function's address - once Dll is loaded into mem the handle is retrieved, the next step is to retrirve function address 
refer to : https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress
```
PVOID pHelloWorld = GetProcAddress(hModule, "HelloWorld");
```

Invoking the function - the next step is to perform type cast on this address 
```
// Constructing a new data type that represents HelloWorld's function pointer
typedef void (WINAPI* HelloWorldFunctionPointer)();

void call(){
    HMODULE hModule = LoadLibraryA("sampleDLL.dll");
    PVOID pHelloWorld = GetProcAddress(hModule, "HelloWorld");
    // Type-casting the 'pHelloWorld' variable to be of type 'HelloWorldFunctionPointer'
    HelloWorldFunctionPointer HelloWorld = (HelloWorldFunctionPointer)pHelloWorld;
    HelloWorld();   // Calling the 'HelloWorld' function via its function pointer
}
```

EXAMPLE: 
```
typedef int (WINAPI* MessageBoxAFunctionPointer)( // Constructing a new data type, that will represent MessageBoxA's function pointer
  HWND          hWnd,
  LPCSTR        lpText,
  LPCSTR        lpCaption,
  UINT          uType
);

void call(){
    // Retrieving MessageBox's address, and saving it to 'pMessageBoxA' (MessageBoxA's function pointer)
    MessageBoxAFunctionPointer pMessageBoxA = (MessageBoxAFunctionPointer)GetProcAddress(LoadLibraryA("user32.dll"), "MessageBoxA");
    if (pMessageBoxA != NULL){
        // Calling MessageBox via its function pointer if not null
        pMessageBoxA(NULL, "MessageBox's Text", "MessageBox's Caption", MB_OK);
    }
}
```

function pointers
- represented by fn if MessageBOXAFunctionPointer the datatype will be fnMessageBoxA
- used for simplicity and clarity
### **Rundll32.exe**

There are a couple of ways to run exported functions without using a programmatical method. One common technique is to use the rundll32.exe binary. `Rundll32.exe` is a built-in Windows binary that is used to run an exported function of a DLL file. To run an exported function use the following command:

```
rundll32.exe <dllname>, <function exported to run>
```

For example, `User32.dll` exports the function `LockWorkStation` which locks the machine. To run the function, use the following command:

```
rundll32.exe user32.dll,LockWorkStation
```

Refer To : https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/rundll32

## creating a DLL with VScode

![[Pasted image 20240512180216.png]]

![[Pasted image 20240512180247.png]]

- The provided DLL template comes with `framework.h`, `pch.h` and `pch.cpp` which are known as [Precompiled Headers](https://en.wikipedia.org/wiki/Precompiled_header). 
- These are files used to make the project compilation faster for large projects. It is unlikely that these will be required in this situation and therefore it is recommended to delete these files. To do so, highlight the file and press the delete key and select the 'Delete' option.
precompile headers is compiled into an intermediate form faster to process for compiler

