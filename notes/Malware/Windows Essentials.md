![[Pasted image 20240511123230.png]]

- user process is something executed by the user sunch as notepad , google or word.
DLL
 - refer to this  https://learn.microsoft.com/en-us/troubleshoot/windows-client/setup-upgrade-and-drivers/dynamic-link-library
 - provides functionality of OS
 - contains code and data can be used  by more than one program 
Subsystem Dll contain API functionality called by user processes example is kernel32.dll
- https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea (Within kernel32.dll, there exists a function called `CreateFile`. This function is part of the Windows API (WinAPI), which is a set of functions and procedures that allows developers to interact with the Windows operating system.)

- api functions allow diff software apps to communicate with each other refer https://www.indeed.com/career-advice/career-development/api-functions

**Ntdll.dll** (system wide dll)
- system wide dll means it is accessible and utilized by multiple programs across entire system (contains essential functions)
- it is lowers layer available in user mode (serves as gateway b/w 2 modes)
- this dll provides transition of execution from user mode to kernel mode
	- here transitions means that (sometimes when user executes program they require high privileges to access that process so it must transition from user mode to kernel mode(accomplished by system calls))
- also referred to as native API

Executive kernel is known as window kernel it calls drivers and modules wihtin kernel mode to complete tasks

###  **Function Call Flow**
![[Pasted image 20240511130021.png]]


a function call begins with user application calling create file WINAPI function in kernel32.dll
createfile calls it's equivalent NTAPI function NtCreateFile providd through Ntdll then execute assembly  or sys call instruction which transfers execution to kernel mode , once execution enters kernel mode kernel's implementation of the NtCreateFile function is invoked (handles I/O op, access control checks etc)

### **Example**
![[Pasted image 20240511130846.png]]
Windows API simply acts as a wrapper for the Native API. With that being said, the Native API is more difficult to use because it is not officially documented by Microsoft. Furthermore, Microsoft advises against the use of Native API functions because they can be changed at any time without warning.



### Memory management
![[Pasted image 20240511131015.png]]

Instead of directly accessing physical memory addresses, processes interact with virtual memory addresses, which are then mapped to physical memory addresses by the operating system.
This mapping allows for several benefits, including efficient memory utilization and the ability to run multiple processes simultaneously while maintaining isolation between them.

- pages within virtual memory can be in 3 states
	 - free (neither committed nor reserved not accessible to the process available to be reserved or committed )
	 - reserved - reserved for future use
	 - committed - can be accessible and access is controlled by memory protection contestants

### Page -protection
```
PAGE_NOACCESS
PAGE_EXECUTE_READWRITE
PAGE_READONLY
```
### **Memory Protection**
Data Execution Prevention (DEP) -  prevent executing code in that region
Address space layout randomization (ASLR) - prevent exploitation of memory corruption vuln

### **x86 vs x64 Memory Space**

When working with Windows processes, it's important to note whether the process is x86 or x64. x86 processes have a smaller memory space of 4GB (`0xFFFFFFFF`) whereas x64 has a vastly larger memory space of 128TB (`0xFFFFFFFFFFFFFFFF`).


we can interact with windows memory via C
```
/ Allocating a memory buffer of *100* bytes

// Method 1 - Using malloc()
PVOID pAddress = malloc(100);

// Method 2 - Using HeapAlloc()
PVOID pAddress = HeapAlloc(GetProcessHeap(), 0, 100);

// Method 3 - Using LocalAlloc()
PVOID pAddress = LocalAlloc(LPTR, 100);
```

Memory allocation functions return the _base address_ which is simply a pointer to the beginning of the memory block that was allocated.

`pAddress` looks like
![[Pasted image 20240511132028.png]]

When memory is allocated, it may either be empty or contain random data. Some memory allocation functions provide an option to zero out the memory region during the allocation process.
![[Pasted image 20240511132045.png]]
next step after memory allocation is generally writing to that buffer. Several options can be used to write to memory but for this example, `memcpy` is used.

```
PVOID pAddress	= HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 100);

CHAR* cString	= "MalDev Academy Is The Best";

memcpy(pAddress, cString, strlen(cString));
```

`HeapAlloc` uses the `HEAP_ZERO_MEMORY` flag which causes the allocated memory to be initialized to zero. The string is then copied to the allocated memory using `memcpy`. The last parameter in `memcpy` is the number of bytes to be copied. Next, recheck the buffer to verify that the data was successfully written
![[Pasted image 20240511132154.png]]


### Freeing allocated memory
- Allocating with `malloc` requires the use of the `free` function.

- Allocating with `HeapAlloc` requires the use of the `HeapFree` function.

- Allocating with `LocalAlloc` requires the use of the `LocalFree` function.
When the application is done using an allocated buffer, it is highly recommended to deallocate or free the buffer to avoid memory leaks refer https://en.wikipedia.org/wiki/Memory_leak

The images below show `HeapFree` in action, freeing allocated memory at address `0000023ADE449900`. Notice the address `0000023ADE449900` still exists within the process but its original content was overwritten with random data. This new data is most likely due to a new allocation performed by the OS inside the process.
![[Pasted image 20240511132554.png]]
![[Pasted image 20240511132548.png]]
