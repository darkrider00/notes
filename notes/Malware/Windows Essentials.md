![[Pasted image 20240511123230.png]]

- user process is something executed by the user sunch as notepad , google or word.
DLL
 - refer to this  https://learn.microsoft.com/en-us/troubleshoot/windows-client/setup-upgrade-and-drivers/dynamic-link-library
 - provides functionality of OS
 - contains code and data can be used  by more than one program 
Subsystem Dll contain API functionality called by user processes example is kernel32.dll
- https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea (Within kernel32.dll, there exists a function called `CreateFile`. This function is part of the Windows API (WinAPI), which is a set of functions and procedures that allows developers to interact with the Windows operating system.)

- api functions allow diff software apps to communicate with each other refer https://www.indeed.com/career-advice/career-development/api-functions

**Ntdll.dll** (system wide dll)
- system wide dll means it is accessible and utilized by multiple programs across entire system (contains essential functions)
- it is lowers layer available in user mode (serves as gateway b/w 2 modes)
- this dll provides transition of execution from user mode to kernel mode
	- here transitions means that (sometimes when user executes program they require high privileges to access that process so it must transition from user mode to kernel mode(accomplished by system calls))
- also referred to as native API

Executive kernel is known as window kernel it calls drivers and modules wihtin kernel mode to complete tasks

###  **Function Call Flow**
![[Pasted image 20240511130021.png]]


a function call begins with user application calling create file WINAPI function in kernel32.dll
createfile calls it's equivalent NTAPI function NtCreateFile providd through Ntdll then execute assembly  or sys call instruction which transfers execution to kernel mode , once execution enters kernel mode kernel's implementation of the NtCreateFile function is invoked (handles I/O op, access control checks etc)

### **Example**
![[Pasted image 20240511130846.png]]
Windows API simply acts as a wrapper for the Native API. With that being said, the Native API is more difficult to use because it is not officially documented by Microsoft. Furthermore, Microsoft advises against the use of Native API functions because they can be changed at any time without warning.



### Memory management
![[Pasted image 20240511131015.png]]

Instead of directly accessing physical memory addresses, processes interact with virtual memory addresses, which are then mapped to physical memory addresses by the operating system.
This mapping allows for several benefits, including efficient memory utilization and the ability to run multiple processes simultaneously while maintaining isolation between them.

- pages within virtual memory can be in 3 states
	 - free (neither committed nor reserved not accessible to the process available to be reserved or committed )
	 - reserved - reserved for future use
	 - committed - can be accessible and access is controlled by memory protection contestants

### Page -protection
```
PAGE_NOACCESS
PAGE_EXECUTE_READWRITE
PAGE_READONLY
```
### **Memory Protection**
Data Execution Prevention (DEP) -  prevent executing code in that region
Address space layout randomization (ASLR) - prevent exploitation of memory corruption vuln

### **x86 vs x64 Memory Space**

When working with Windows processes, it's important to note whether the process is x86 or x64. x86 processes have a smaller memory space of 4GB (`0xFFFFFFFF`) whereas x64 has a vastly larger memory space of 128TB (`0xFFFFFFFFFFFFFFFF`).


we can interact with windows memory via C
```
/ Allocating a memory buffer of *100* bytes

// Method 1 - Using malloc()
PVOID pAddress = malloc(100);

// Method 2 - Using HeapAlloc()
PVOID pAddress = HeapAlloc(GetProcessHeap(), 0, 100);

// Method 3 - Using LocalAlloc()
PVOID pAddress = LocalAlloc(LPTR, 100);
```

Memory allocation functions return the _base address_ which is simply a pointer to the beginning of the memory block that was allocated.

`pAddress` looks like
![[Pasted image 20240511132028.png]]

When memory is allocated, it may either be empty or contain random data. Some memory allocation functions provide an option to zero out the memory region during the allocation process.
![[Pasted image 20240511132045.png]]
next step after memory allocation is generally writing to that buffer. Several options can be used to write to memory but for this example, `memcpy` is used.

```
PVOID pAddress	= HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 100);

CHAR* cString	= "MalDev Academy Is The Best";

memcpy(pAddress, cString, strlen(cString));
```

`HeapAlloc` uses the `HEAP_ZERO_MEMORY` flag which causes the allocated memory to be initialized to zero. The string is then copied to the allocated memory using `memcpy`. The last parameter in `memcpy` is the number of bytes to be copied. Next, recheck the buffer to verify that the data was successfully written
![[Pasted image 20240511132154.png]]


### Freeing allocated memory
- Allocating with `malloc` requires the use of the `free` function.

- Allocating with `HeapAlloc` requires the use of the `HeapFree` function.

- Allocating with `LocalAlloc` requires the use of the `LocalFree` function.
When the application is done using an allocated buffer, it is highly recommended to deallocate or free the buffer to avoid memory leaks refer https://en.wikipedia.org/wiki/Memory_leak

The images below show `HeapFree` in action, freeing allocated memory at address `0000023ADE449900`. Notice the address `0000023ADE449900` still exists within the process but its original content was overwritten with random data. This new data is most likely due to a new allocation performed by the OS inside the process.
![[Pasted image 20240511132554.png]]
![[Pasted image 20240511132548.png]]

## Windows API
way for application to interact with OS
example : if app needs to display something on screen or modify all these actions can be done via Windows API

**data types :**
refer [https://learn.microsoft.com/en-us/windows/win32/winprog/windows-data-types]

DWORD -32 it unsigned integer both 32 bit and 64 bit 
```
DWORD dwVariable = 42;
```
size_t - 32 bit unsigned int (2^32-1)
```
SIZE_T sVariable = sizeof(int);
```
VOID -abscence
```
void* pVariable = NULL; // This is the same as PVOID
```
Pvoid -32 bit pointer of any data type
```
PVOID pVariable = &SomeData;
```
HANDLE -value that specifies specific object
```
HANDLE hFile = CreateFile(...);
```
HMODULE - handle module 
```
HMODULE hModule = GetModuleHandle(...);
```
etc refere to the link for more 

#### Data Type Pointers

- `PHANDLE` is the same as `HANDLE*`.

- `PSIZE_T` is the same as `SIZE_T*`.

- `PDWORD` is the same as `DWORD*`.

#### **ANSI & Unicode Functions**
The majority of Windows API functions have two versions ending with either "A" or with "W". For example, there is [CreateFileA](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea) and [CreateFileW](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew). The functions ending with "A" are meant to indicate "ANSI" whereas the functions ending with "W" represent Unicode or "Wide".
- Ansi function (8 bits) will take ANSI data type as parameters
	 - each char occupies one byte and null terminator (total mem = num of char + null terminator)
- Unicode function (16 bits) will take in Unicode as data types
     - each char occupies 2 bytes (total mem is num of char multiplied by 2 +2 for null terminator)
```
first parameter for `CreateFileA` is an `LPCSTR`, which is a pointer to a constant null-terminated string of **8-bit** Windows ANSI characters. On the other hand, the first parameter for `CreateFileW` is `LPCWSTR`, a pointer to a constant null-terminated string of **16-bit** Unicode characters.

Furthermore, the number of required bytes will differ depending on which version is used.

`char str1[] = "maldev";` // 7 bytes (maldev + [null byte]
`wchar str2[] = L"maldev";` // 14 bytes, each character is 2 bytes (The null byte is also 2 bytes)
```
refer https://www.tutorialandexample.com/null-character-in-c

### **Find the API Reference**

It's important to always reference the documentation if one is unsure about what the function does or what arguments it requires.
example 
The `CreateFileW` documentation is available [here](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew).

```
HANDLE CreateFileW(
  [in]           LPCWSTR               lpFileName,
  [in]           DWORD                 dwDesiredAccess,
  [in]           DWORD                 dwShareMode,
  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  [in]           DWORD                 dwCreationDisposition,
  [in]           DWORD                 dwFlagsAndAttributes,
  [in, optional] HANDLE                hTemplateFile
);
```

- When you use `CreateFileW` successfully, it gives you something called a "handle." This handle is like a ticket that allows you to interact with the file or device you created or opened.
- When you use CreateFileW, you provide it with some information about what you want to create or open. These are things like the name of the file or device, how you want to use it, and any special options.

#### using the function
The sample code below goes through an example usage of `CreateFileW`. It will create a text file with the name `maldev.txt` on the current user's Desktop.

```
// This is needed to store the handle to the file object
// the 'INVALID_HANDLE_VALUE' is just to intialize the variable
Handle hFile = INVALID_HANDLE_VALUE;

// The full path of the file to create.
// Double backslashes are required to escape the single backslash character in C
LPCWSTR filePath = L"C:\\Users\\maldevacademy\\Desktop\\maldev.txt";

// Call CreateFileW with the file path
// The additional parameters are directly from the documentation
hFile = CreateFileW(filePath, GENERIC_ALL, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

// On failure CreateFileW returns INVALID_HANDLE_VALUE
// GetLastError() is another Windows API that retrieves the error code of the previously executed WinAPI function
if (hFile == INVALID_HANDLE_VALUE){
    printf("[-] CreateFileW Api Function Failed With Error : %d\n", GetLastError());
    return -1;
}
```

if the CreateFileW fails it returns INVALID_HANDLE_VALUE which indicates file is not created , to gain more insights error code must be retrieved using GetLastError method
to know more about this error handling technique refer :https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror
 once we get the information about the error we can look up in error codes list
 refer https://learn.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-
 
- `5` - ERROR_ACCESS_DENIED

- `2` - ERROR_FILE_NOT_FOUND

- `87` - ERROR_INVALID_PARAMETER

are common error codes

### **Windows Native API Debugging Errors**
NY